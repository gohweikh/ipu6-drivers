From 1579c0efe49c59b13e038c9207437eb3d3596c0b Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Tue, 10 Jun 2025 11:39:54 +0800
Subject: [PATCH] fix the mistake psys driver

Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/pci/intel/ipu6/psys/ipu-psys.c  | 86 +++++++++++++------
 drivers/media/pci/intel/ipu6/psys/ipu-psys.h  |  1 +
 drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c  |  8 +-
 drivers/media/pci/intel/ipu6/psys/ipu6-psys.c | 24 +++---
 4 files changed, 80 insertions(+), 39 deletions(-)

diff --git a/drivers/media/pci/intel/ipu6/psys/ipu-psys.c b/drivers/media/pci/intel/ipu6/psys/ipu-psys.c
index cab60f4ba..9f367496c 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu-psys.c
+++ b/drivers/media/pci/intel/ipu6/psys/ipu-psys.c
@@ -168,7 +168,6 @@ static struct ipu_psys_desc *ipu_psys_desc_alloc(int fd)
 
 struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
 {
-	struct device *dev = &psys->adev->auxdev.dev;
 	struct ipu_psys_pg *kpg;
 	unsigned long flags;
 
@@ -186,8 +185,8 @@ struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
 	if (!kpg)
 		return NULL;
 
-	kpg->pg = dma_alloc_attrs(dev, pg_size,  &kpg->pg_dma_addr,
-				  GFP_KERNEL, 0);
+	kpg->pg = ipu6_dma_alloc(psys->adev, pg_size,  &kpg->pg_dma_addr,
+				 GFP_KERNEL, 0);
 	if (!kpg->pg) {
 		kfree(kpg);
 		return NULL;
@@ -398,23 +397,28 @@ static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
 					enum dma_data_direction dir)
 {
 	struct ipu_dma_buf_attach *ipu_attach = attach->priv;
+	struct pci_dev *pdev = to_pci_dev(attach->dev);
+	struct ipu6_device *isp = pci_get_drvdata(pdev);
+	struct ipu6_bus_device *adev = isp->psys;
 	unsigned long attrs;
 	int ret;
 
 	attrs = DMA_ATTR_SKIP_CPU_SYNC;
-	ret = dma_map_sgtable(attach->dev, ipu_attach->sgt, dir, attrs);
-	if (ret < 0) {
-		dev_dbg(attach->dev, "buf map failed\n");
+	ret = dma_map_sgtable(&pdev->dev, ipu_attach->sgt, dir, attrs);
+	if (ret) {
+		dev_err(attach->dev, "pci buf map failed\n");
+		return ERR_PTR(-EIO);
+	}
+
+	dma_sync_sgtable_for_device(&pdev->dev, ipu_attach->sgt, dir);
 
+	ret = ipu6_dma_map_sgtable(adev, ipu_attach->sgt, dir, 0);
+	if (ret) {
+		dev_err(attach->dev, "ipu6 buf map failed\n");
 		return ERR_PTR(-EIO);
 	}
 
-	/*
-	 * Initial cache flush to avoid writing dirty pages for buffers which
-	 * are later marked as IPU_BUFFER_FLAG_NO_FLUSH.
-	 */
-	dma_sync_sg_for_device(attach->dev, ipu_attach->sgt->sgl,
-			       ipu_attach->sgt->orig_nents, DMA_BIDIRECTIONAL);
+	ipu6_dma_sync_sgtable(adev, ipu_attach->sgt);
 
 	return ipu_attach->sgt;
 }
@@ -422,8 +426,12 @@ static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
 static void ipu_dma_buf_unmap(struct dma_buf_attachment *attach,
 			      struct sg_table *sgt, enum dma_data_direction dir)
 {
+	struct pci_dev *pdev = to_pci_dev(attach->dev);
+	struct ipu6_device *isp = pci_get_drvdata(pdev);
+	struct ipu6_bus_device *adev = isp->psys;
 
-	dma_unmap_sgtable(attach->dev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);
+	ipu6_dma_unmap_sgtable(adev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);
+	dma_unmap_sgtable(&pdev->dev, sgt, dir, 0);
 }
 
 static int ipu_dma_buf_mmap(struct dma_buf *dbuf, struct vm_area_struct *vma)
@@ -539,7 +547,8 @@ open_failed:
 	return rval;
 }
 
-static inline void ipu_psys_kbuf_unmap(struct ipu_psys_kbuffer *kbuf)
+static inline void ipu_psys_kbuf_unmap(struct ipu_psys_fh *fh,
+				       struct ipu_psys_kbuffer *kbuf)
 {
 	if (!kbuf)
 		return;
@@ -552,6 +561,10 @@ static inline void ipu_psys_kbuf_unmap(struct ipu_psys_kbuffer *kbuf)
 		dma_buf_vunmap_unlocked(kbuf->dbuf, &dmap);
 	}
 
+	if (!kbuf->userptr)
+		ipu6_dma_unmap_sgtable(fh->psys->adev, kbuf->sgt,
+				       DMA_BIDIRECTIONAL, 0);
+
 	if (!IS_ERR_OR_NULL(kbuf->sgt))
 		dma_buf_unmap_attachment_unlocked(kbuf->db_attach,
 						  kbuf->sgt,
@@ -569,7 +582,7 @@ static void __ipu_psys_unmapbuf(struct ipu_psys_fh *fh,
 				struct ipu_psys_kbuffer *kbuf)
 {
 	/* From now on it is not safe to use this kbuffer */
-	ipu_psys_kbuf_unmap(kbuf);
+	ipu_psys_kbuf_unmap(fh, kbuf);
 	ipu_buffer_del(fh, kbuf);
 	if (!kbuf->userptr)
 		kfree(kbuf);
@@ -649,7 +662,7 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 
 		/* Unmap and release buffers */
 		if (kbuf->dbuf && db_attach) {
-			ipu_psys_kbuf_unmap(kbuf);
+			ipu_psys_kbuf_unmap(fh, kbuf);
 		} else {
 			if (db_attach)
 				ipu_psys_put_userpages(db_attach->priv);
@@ -762,7 +775,8 @@ static void ipu_psys_kbuffer_lru(struct ipu_psys_fh *fh,
 struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 {
 	struct ipu_psys *psys = fh->psys;
-	struct device *dev = &psys->adev->auxdev.dev;
+	struct device *dev = &psys->adev->isp->pdev->dev;
+	int ret;
 	struct ipu_psys_kbuffer *kbuf;
 	struct ipu_psys_desc *desc;
 	struct dma_buf *dbuf;
@@ -819,7 +833,7 @@ struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 	kbuf->db_attach = dma_buf_attach(kbuf->dbuf, dev);
 	if (IS_ERR(kbuf->db_attach)) {
 		dev_dbg(dev, "dma buf attach failed\n");
-		goto kbuf_map_fail;
+		goto attach_fail;
 	}
 
 	kbuf->sgt = dma_buf_map_attachment_unlocked(kbuf->db_attach,
@@ -830,6 +844,15 @@ struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 		goto kbuf_map_fail;
 	}
 
+	if (!kbuf->userptr) {
+		ret = ipu6_dma_map_sgtable(psys->adev, kbuf->sgt,
+					   DMA_BIDIRECTIONAL, 0);
+		if (ret) {
+			dev_dbg(dev, "ipu6 buf map failed\n");
+			goto kbuf_map_fail;
+		}
+	}
+
 	kbuf->dma_addr = sg_dma_address(kbuf->sgt->sgl);
 
 	dmap.is_iomem = false;
@@ -840,15 +863,25 @@ struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 	kbuf->kaddr = dmap.vaddr;
 
 mapbuf_end:
-	dev_dbg(dev, "%s kbuf %p fd %d with len %llu mapped\n",
-		__func__, kbuf, fd, kbuf->len);
+	dev_dbg(dev, "%s %s kbuf %p fd %d with len %llu mapped\n",
+		__func__, kbuf->userptr ? "private" : "imported", kbuf, fd,
+		kbuf->len);
 
 	kbuf->valid = true;
 	return kbuf;
 
 kbuf_map_fail:
 	ipu_buffer_del(fh, kbuf);
-	ipu_psys_kbuf_unmap(kbuf);
+	if (!IS_ERR_OR_NULL(kbuf->sgt)) {
+		if (!kbuf->userptr)
+			ipu6_dma_unmap_sgtable(psys->adev, kbuf->sgt,
+					       DMA_BIDIRECTIONAL, 0);
+		dma_buf_unmap_attachment_unlocked(kbuf->db_attach, kbuf->sgt,
+						  DMA_BIDIRECTIONAL);
+	}
+	dma_buf_detach(kbuf->dbuf, kbuf->db_attach);
+attach_fail:
+	ipu_buffer_del(fh, kbuf);
 	dbuf = ERR_PTR(-EINVAL);
 	if (!kbuf->userptr)
 		kfree(kbuf);
@@ -1359,9 +1392,9 @@ static int ipu6_psys_probe(struct auxiliary_device *auxdev,
 		kpg = kzalloc(sizeof(*kpg), GFP_KERNEL);
 		if (!kpg)
 			goto out_free_pgs;
-		kpg->pg = dma_alloc_attrs(dev, IPU_PSYS_PG_MAX_SIZE,
-					  &kpg->pg_dma_addr,
-					  GFP_KERNEL, 0);
+		kpg->pg = ipu6_dma_alloc(adev, IPU_PSYS_PG_MAX_SIZE,
+					 &kpg->pg_dma_addr,
+					 GFP_KERNEL, 0);
 		if (!kpg->pg) {
 			kfree(kpg);
 			goto out_free_pgs;
@@ -1421,7 +1454,7 @@ out_release_fw_com:
 	ipu6_fw_com_release(psys->fwcom, 1);
 out_free_pgs:
 	list_for_each_entry_safe(kpg, kpg0, &psys->pgs, list) {
-		dma_free_attrs(dev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
+		ipu6_dma_free(adev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
 		kfree(kpg);
 	}
 
@@ -1441,6 +1474,7 @@ out_unlock:
 
 static void ipu6_psys_remove(struct auxiliary_device *auxdev)
 {
+	struct ipu6_bus_device *adev = auxdev_to_adev(auxdev);
 	struct device *dev = &auxdev->dev;
 	struct ipu_psys *psys = dev_get_drvdata(&auxdev->dev);
 	struct ipu_psys_pg *kpg, *kpg0;
@@ -1453,7 +1487,7 @@ static void ipu6_psys_remove(struct auxiliary_device *auxdev)
 	mutex_lock(&ipu_psys_mutex);
 
 	list_for_each_entry_safe(kpg, kpg0, &psys->pgs, list) {
-		dma_free_attrs(dev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
+		ipu6_dma_free(adev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
 		kfree(kpg);
 	}
 
diff --git a/drivers/media/pci/intel/ipu6/psys/ipu-psys.h b/drivers/media/pci/intel/ipu6/psys/ipu-psys.h
index df3e84174..8af6551fe 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu-psys.h
+++ b/drivers/media/pci/intel/ipu6/psys/ipu-psys.h
@@ -10,6 +10,7 @@
 #include <linux/version.h>
 #include "ipu6.h"
 #include "ipu6-bus.h"
+#include "ipu6-dma.h"
 #include "ipu-fw-psys.h"
 #include "ipu-platform-psys.h"
 
diff --git a/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c b/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c
index 8efa7cf41..b6a90f8a8 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c
+++ b/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c
@@ -6,6 +6,7 @@
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
 
+#include "ipu6-dma.h"
 #include "ipu6-ppg.h"
 
 static bool enable_suspend_resume;
@@ -48,7 +49,7 @@ struct ipu_psys_kcmd *ipu_psys_ppg_get_stop_kcmd(struct ipu_psys_ppg *kppg)
 static struct ipu_psys_buffer_set *
 __get_buf_set(struct ipu_psys_fh *fh, size_t buf_set_size)
 {
-	struct device *dev = &fh->psys->adev->auxdev.dev;
+	struct ipu6_bus_device *adev = fh->psys->adev;
 	struct ipu_psys_buffer_set *kbuf_set;
 	struct ipu_psys_scheduler *sched = &fh->sched;
 
@@ -68,8 +69,8 @@ __get_buf_set(struct ipu_psys_fh *fh, size_t buf_set_size)
 	if (!kbuf_set)
 		return NULL;
 
-	kbuf_set->kaddr = dma_alloc_attrs(dev, buf_set_size,
-					  &kbuf_set->dma_addr, GFP_KERNEL, 0);
+	kbuf_set->kaddr = ipu6_dma_alloc(adev, buf_set_size,
+					 &kbuf_set->dma_addr, GFP_KERNEL, 0);
 	if (!kbuf_set->kaddr) {
 		kfree(kbuf_set);
 		return NULL;
@@ -111,6 +112,7 @@ ipu_psys_create_buffer_set(struct ipu_psys_kcmd *kcmd,
 					    kbuf_set->dma_addr);
 	keb = kcmd->kernel_enable_bitmap;
 	ipu_fw_psys_ppg_buffer_set_set_keb(kbuf_set->buf_set, keb);
+	ipu6_dma_sync_single(psys->adev, kbuf_set->dma_addr, buf_set_size);
 
 	return kbuf_set;
 }
diff --git a/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c b/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c
index af4669828..46c6bc885 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c
+++ b/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c
@@ -15,6 +15,7 @@
 #include <linux/fs.h>
 
 #include "ipu6.h"
+#include "ipu6-dma.h"
 #include "ipu-psys.h"
 #include "ipu6-ppg.h"
 #include "ipu6-platform-regs.h"
@@ -327,9 +328,13 @@ static struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
 
 		prevfd = kcmd->buffers[i].base.fd;
 
-		dma_sync_sg_for_device(dev, kcmd->kbufs[i]->sgt->sgl,
-				       kcmd->kbufs[i]->sgt->orig_nents,
-				       DMA_BIDIRECTIONAL);
+		/*
+		 * TODO: remove exported buffer sync here as the cache
+		 * coherency should be done by the exporter
+		 */
+		if (kcmd->kbufs[i]->kaddr)
+			clflush_cache_range(kcmd->kbufs[i]->kaddr,
+					    kcmd->kbufs[i]->len);
 	}
 
 	if (kcmd->state != KCMD_STATE_PPG_START)
@@ -856,7 +861,6 @@ void ipu_psys_handle_events(struct ipu_psys *psys)
 int ipu_psys_fh_init(struct ipu_psys_fh *fh)
 {
 	struct ipu_psys *psys = fh->psys;
-	struct device *dev = &psys->adev->auxdev.dev;
 	struct ipu_psys_buffer_set *kbuf_set, *kbuf_set_tmp;
 	struct ipu_psys_scheduler *sched = &fh->sched;
 	int i;
@@ -870,10 +874,10 @@ int ipu_psys_fh_init(struct ipu_psys_fh *fh)
 		kbuf_set = kzalloc(sizeof(*kbuf_set), GFP_KERNEL);
 		if (!kbuf_set)
 			goto out_free_buf_sets;
-		kbuf_set->kaddr = dma_alloc_attrs(dev,
-						  IPU_PSYS_BUF_SET_MAX_SIZE,
-						  &kbuf_set->dma_addr,
-						  GFP_KERNEL, 0);
+		kbuf_set->kaddr = ipu6_dma_alloc(psys->adev,
+						 IPU_PSYS_BUF_SET_MAX_SIZE,
+						 &kbuf_set->dma_addr,
+						 GFP_KERNEL, 0);
 		if (!kbuf_set->kaddr) {
 			kfree(kbuf_set);
 			goto out_free_buf_sets;
@@ -887,7 +891,7 @@ int ipu_psys_fh_init(struct ipu_psys_fh *fh)
 out_free_buf_sets:
 	list_for_each_entry_safe(kbuf_set, kbuf_set_tmp,
 				 &sched->buf_sets, list) {
-		dma_free_attrs(dev, kbuf_set->size, kbuf_set->kaddr,
+		ipu6_dma_free(psys->adev, kbuf_set->size, kbuf_set->kaddr,
 			      kbuf_set->dma_addr, 0);
 		list_del(&kbuf_set->list);
 		kfree(kbuf_set);
@@ -978,7 +982,7 @@ int ipu_psys_fh_deinit(struct ipu_psys_fh *fh)
 
 	mutex_lock(&sched->bs_mutex);
 	list_for_each_entry_safe(kbuf_set, kbuf_set0, &sched->buf_sets, list) {
-		dma_free_attrs(dev, kbuf_set->size, kbuf_set->kaddr,
+		ipu6_dma_free(psys->adev, kbuf_set->size, kbuf_set->kaddr,
 			      kbuf_set->dma_addr, 0);
 		list_del(&kbuf_set->list);
 		kfree(kbuf_set);
-- 
2.43.0

