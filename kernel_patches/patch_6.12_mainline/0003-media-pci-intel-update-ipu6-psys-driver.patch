From 4c720489b77aaf84670a4e07df491ea625348c8d Mon Sep 17 00:00:00 2001
From: zouxiaoh <xiaohong.zou@intel.com>
Date: Mon, 19 May 2025 14:24:14 +0800
Subject: [PATCH] media: pci: intel: update ipu6 psys driver

Signed-off-by: zouxiaoh <xiaohong.zou@intel.com>
---
 drivers/media/pci/intel/ipu6/psys/ipu-psys.c  | 86 ++++++-------------
 drivers/media/pci/intel/ipu6/psys/ipu-psys.h  |  1 -
 drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c  |  8 +-
 drivers/media/pci/intel/ipu6/psys/ipu6-psys.c | 24 +++---
 4 files changed, 39 insertions(+), 80 deletions(-)

diff --git a/drivers/media/pci/intel/ipu6/psys/ipu-psys.c b/drivers/media/pci/intel/ipu6/psys/ipu-psys.c
index 9f367496c..cab60f4ba 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu-psys.c
+++ b/drivers/media/pci/intel/ipu6/psys/ipu-psys.c
@@ -168,6 +168,7 @@ static struct ipu_psys_desc *ipu_psys_desc_alloc(int fd)
 
 struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
 {
+	struct device *dev = &psys->adev->auxdev.dev;
 	struct ipu_psys_pg *kpg;
 	unsigned long flags;
 
@@ -185,8 +186,8 @@ struct ipu_psys_pg *__get_pg_buf(struct ipu_psys *psys, size_t pg_size)
 	if (!kpg)
 		return NULL;
 
-	kpg->pg = ipu6_dma_alloc(psys->adev, pg_size,  &kpg->pg_dma_addr,
-				 GFP_KERNEL, 0);
+	kpg->pg = dma_alloc_attrs(dev, pg_size,  &kpg->pg_dma_addr,
+				  GFP_KERNEL, 0);
 	if (!kpg->pg) {
 		kfree(kpg);
 		return NULL;
@@ -397,28 +398,23 @@ static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
 					enum dma_data_direction dir)
 {
 	struct ipu_dma_buf_attach *ipu_attach = attach->priv;
-	struct pci_dev *pdev = to_pci_dev(attach->dev);
-	struct ipu6_device *isp = pci_get_drvdata(pdev);
-	struct ipu6_bus_device *adev = isp->psys;
 	unsigned long attrs;
 	int ret;
 
 	attrs = DMA_ATTR_SKIP_CPU_SYNC;
-	ret = dma_map_sgtable(&pdev->dev, ipu_attach->sgt, dir, attrs);
-	if (ret) {
-		dev_err(attach->dev, "pci buf map failed\n");
-		return ERR_PTR(-EIO);
-	}
-
-	dma_sync_sgtable_for_device(&pdev->dev, ipu_attach->sgt, dir);
+	ret = dma_map_sgtable(attach->dev, ipu_attach->sgt, dir, attrs);
+	if (ret < 0) {
+		dev_dbg(attach->dev, "buf map failed\n");
 
-	ret = ipu6_dma_map_sgtable(adev, ipu_attach->sgt, dir, 0);
-	if (ret) {
-		dev_err(attach->dev, "ipu6 buf map failed\n");
 		return ERR_PTR(-EIO);
 	}
 
-	ipu6_dma_sync_sgtable(adev, ipu_attach->sgt);
+	/*
+	 * Initial cache flush to avoid writing dirty pages for buffers which
+	 * are later marked as IPU_BUFFER_FLAG_NO_FLUSH.
+	 */
+	dma_sync_sg_for_device(attach->dev, ipu_attach->sgt->sgl,
+			       ipu_attach->sgt->orig_nents, DMA_BIDIRECTIONAL);
 
 	return ipu_attach->sgt;
 }
@@ -426,12 +422,8 @@ static struct sg_table *ipu_dma_buf_map(struct dma_buf_attachment *attach,
 static void ipu_dma_buf_unmap(struct dma_buf_attachment *attach,
 			      struct sg_table *sgt, enum dma_data_direction dir)
 {
-	struct pci_dev *pdev = to_pci_dev(attach->dev);
-	struct ipu6_device *isp = pci_get_drvdata(pdev);
-	struct ipu6_bus_device *adev = isp->psys;
 
-	ipu6_dma_unmap_sgtable(adev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);
-	dma_unmap_sgtable(&pdev->dev, sgt, dir, 0);
+	dma_unmap_sgtable(attach->dev, sgt, dir, DMA_ATTR_SKIP_CPU_SYNC);
 }
 
 static int ipu_dma_buf_mmap(struct dma_buf *dbuf, struct vm_area_struct *vma)
@@ -547,8 +539,7 @@ open_failed:
 	return rval;
 }
 
-static inline void ipu_psys_kbuf_unmap(struct ipu_psys_fh *fh,
-				       struct ipu_psys_kbuffer *kbuf)
+static inline void ipu_psys_kbuf_unmap(struct ipu_psys_kbuffer *kbuf)
 {
 	if (!kbuf)
 		return;
@@ -561,10 +552,6 @@ static inline void ipu_psys_kbuf_unmap(struct ipu_psys_fh *fh,
 		dma_buf_vunmap_unlocked(kbuf->dbuf, &dmap);
 	}
 
-	if (!kbuf->userptr)
-		ipu6_dma_unmap_sgtable(fh->psys->adev, kbuf->sgt,
-				       DMA_BIDIRECTIONAL, 0);
-
 	if (!IS_ERR_OR_NULL(kbuf->sgt))
 		dma_buf_unmap_attachment_unlocked(kbuf->db_attach,
 						  kbuf->sgt,
@@ -582,7 +569,7 @@ static void __ipu_psys_unmapbuf(struct ipu_psys_fh *fh,
 				struct ipu_psys_kbuffer *kbuf)
 {
 	/* From now on it is not safe to use this kbuffer */
-	ipu_psys_kbuf_unmap(fh, kbuf);
+	ipu_psys_kbuf_unmap(kbuf);
 	ipu_buffer_del(fh, kbuf);
 	if (!kbuf->userptr)
 		kfree(kbuf);
@@ -662,7 +649,7 @@ static int ipu_psys_release(struct inode *inode, struct file *file)
 
 		/* Unmap and release buffers */
 		if (kbuf->dbuf && db_attach) {
-			ipu_psys_kbuf_unmap(fh, kbuf);
+			ipu_psys_kbuf_unmap(kbuf);
 		} else {
 			if (db_attach)
 				ipu_psys_put_userpages(db_attach->priv);
@@ -775,8 +762,7 @@ static void ipu_psys_kbuffer_lru(struct ipu_psys_fh *fh,
 struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 {
 	struct ipu_psys *psys = fh->psys;
-	struct device *dev = &psys->adev->isp->pdev->dev;
-	int ret;
+	struct device *dev = &psys->adev->auxdev.dev;
 	struct ipu_psys_kbuffer *kbuf;
 	struct ipu_psys_desc *desc;
 	struct dma_buf *dbuf;
@@ -833,7 +819,7 @@ struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 	kbuf->db_attach = dma_buf_attach(kbuf->dbuf, dev);
 	if (IS_ERR(kbuf->db_attach)) {
 		dev_dbg(dev, "dma buf attach failed\n");
-		goto attach_fail;
+		goto kbuf_map_fail;
 	}
 
 	kbuf->sgt = dma_buf_map_attachment_unlocked(kbuf->db_attach,
@@ -844,15 +830,6 @@ struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 		goto kbuf_map_fail;
 	}
 
-	if (!kbuf->userptr) {
-		ret = ipu6_dma_map_sgtable(psys->adev, kbuf->sgt,
-					   DMA_BIDIRECTIONAL, 0);
-		if (ret) {
-			dev_dbg(dev, "ipu6 buf map failed\n");
-			goto kbuf_map_fail;
-		}
-	}
-
 	kbuf->dma_addr = sg_dma_address(kbuf->sgt->sgl);
 
 	dmap.is_iomem = false;
@@ -863,25 +840,15 @@ struct ipu_psys_kbuffer *ipu_psys_mapbuf_locked(int fd, struct ipu_psys_fh *fh)
 	kbuf->kaddr = dmap.vaddr;
 
 mapbuf_end:
-	dev_dbg(dev, "%s %s kbuf %p fd %d with len %llu mapped\n",
-		__func__, kbuf->userptr ? "private" : "imported", kbuf, fd,
-		kbuf->len);
+	dev_dbg(dev, "%s kbuf %p fd %d with len %llu mapped\n",
+		__func__, kbuf, fd, kbuf->len);
 
 	kbuf->valid = true;
 	return kbuf;
 
 kbuf_map_fail:
 	ipu_buffer_del(fh, kbuf);
-	if (!IS_ERR_OR_NULL(kbuf->sgt)) {
-		if (!kbuf->userptr)
-			ipu6_dma_unmap_sgtable(psys->adev, kbuf->sgt,
-					       DMA_BIDIRECTIONAL, 0);
-		dma_buf_unmap_attachment_unlocked(kbuf->db_attach, kbuf->sgt,
-						  DMA_BIDIRECTIONAL);
-	}
-	dma_buf_detach(kbuf->dbuf, kbuf->db_attach);
-attach_fail:
-	ipu_buffer_del(fh, kbuf);
+	ipu_psys_kbuf_unmap(kbuf);
 	dbuf = ERR_PTR(-EINVAL);
 	if (!kbuf->userptr)
 		kfree(kbuf);
@@ -1392,9 +1359,9 @@ static int ipu6_psys_probe(struct auxiliary_device *auxdev,
 		kpg = kzalloc(sizeof(*kpg), GFP_KERNEL);
 		if (!kpg)
 			goto out_free_pgs;
-		kpg->pg = ipu6_dma_alloc(adev, IPU_PSYS_PG_MAX_SIZE,
-					 &kpg->pg_dma_addr,
-					 GFP_KERNEL, 0);
+		kpg->pg = dma_alloc_attrs(dev, IPU_PSYS_PG_MAX_SIZE,
+					  &kpg->pg_dma_addr,
+					  GFP_KERNEL, 0);
 		if (!kpg->pg) {
 			kfree(kpg);
 			goto out_free_pgs;
@@ -1454,7 +1421,7 @@ out_release_fw_com:
 	ipu6_fw_com_release(psys->fwcom, 1);
 out_free_pgs:
 	list_for_each_entry_safe(kpg, kpg0, &psys->pgs, list) {
-		ipu6_dma_free(adev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
+		dma_free_attrs(dev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
 		kfree(kpg);
 	}
 
@@ -1474,7 +1441,6 @@ out_unlock:
 
 static void ipu6_psys_remove(struct auxiliary_device *auxdev)
 {
-	struct ipu6_bus_device *adev = auxdev_to_adev(auxdev);
 	struct device *dev = &auxdev->dev;
 	struct ipu_psys *psys = dev_get_drvdata(&auxdev->dev);
 	struct ipu_psys_pg *kpg, *kpg0;
@@ -1487,7 +1453,7 @@ static void ipu6_psys_remove(struct auxiliary_device *auxdev)
 	mutex_lock(&ipu_psys_mutex);
 
 	list_for_each_entry_safe(kpg, kpg0, &psys->pgs, list) {
-		ipu6_dma_free(adev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
+		dma_free_attrs(dev, kpg->size, kpg->pg, kpg->pg_dma_addr, 0);
 		kfree(kpg);
 	}
 
diff --git a/drivers/media/pci/intel/ipu6/psys/ipu-psys.h b/drivers/media/pci/intel/ipu6/psys/ipu-psys.h
index 8af6551fe..df3e84174 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu-psys.h
+++ b/drivers/media/pci/intel/ipu6/psys/ipu-psys.h
@@ -10,7 +10,6 @@
 #include <linux/version.h>
 #include "ipu6.h"
 #include "ipu6-bus.h"
-#include "ipu6-dma.h"
 #include "ipu-fw-psys.h"
 #include "ipu-platform-psys.h"
 
diff --git a/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c b/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c
index b6a90f8a8..8efa7cf41 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c
+++ b/drivers/media/pci/intel/ipu6/psys/ipu6-ppg.c
@@ -6,7 +6,6 @@
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
 
-#include "ipu6-dma.h"
 #include "ipu6-ppg.h"
 
 static bool enable_suspend_resume;
@@ -49,7 +48,7 @@ struct ipu_psys_kcmd *ipu_psys_ppg_get_stop_kcmd(struct ipu_psys_ppg *kppg)
 static struct ipu_psys_buffer_set *
 __get_buf_set(struct ipu_psys_fh *fh, size_t buf_set_size)
 {
-	struct ipu6_bus_device *adev = fh->psys->adev;
+	struct device *dev = &fh->psys->adev->auxdev.dev;
 	struct ipu_psys_buffer_set *kbuf_set;
 	struct ipu_psys_scheduler *sched = &fh->sched;
 
@@ -69,8 +68,8 @@ __get_buf_set(struct ipu_psys_fh *fh, size_t buf_set_size)
 	if (!kbuf_set)
 		return NULL;
 
-	kbuf_set->kaddr = ipu6_dma_alloc(adev, buf_set_size,
-					 &kbuf_set->dma_addr, GFP_KERNEL, 0);
+	kbuf_set->kaddr = dma_alloc_attrs(dev, buf_set_size,
+					  &kbuf_set->dma_addr, GFP_KERNEL, 0);
 	if (!kbuf_set->kaddr) {
 		kfree(kbuf_set);
 		return NULL;
@@ -112,7 +111,6 @@ ipu_psys_create_buffer_set(struct ipu_psys_kcmd *kcmd,
 					    kbuf_set->dma_addr);
 	keb = kcmd->kernel_enable_bitmap;
 	ipu_fw_psys_ppg_buffer_set_set_keb(kbuf_set->buf_set, keb);
-	ipu6_dma_sync_single(psys->adev, kbuf_set->dma_addr, buf_set_size);
 
 	return kbuf_set;
 }
diff --git a/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c b/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c
index 46c6bc885..af4669828 100644
--- a/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c
+++ b/drivers/media/pci/intel/ipu6/psys/ipu6-psys.c
@@ -15,7 +15,6 @@
 #include <linux/fs.h>
 
 #include "ipu6.h"
-#include "ipu6-dma.h"
 #include "ipu-psys.h"
 #include "ipu6-ppg.h"
 #include "ipu6-platform-regs.h"
@@ -328,13 +327,9 @@ static struct ipu_psys_kcmd *ipu_psys_copy_cmd(struct ipu_psys_command *cmd,
 
 		prevfd = kcmd->buffers[i].base.fd;
 
-		/*
-		 * TODO: remove exported buffer sync here as the cache
-		 * coherency should be done by the exporter
-		 */
-		if (kcmd->kbufs[i]->kaddr)
-			clflush_cache_range(kcmd->kbufs[i]->kaddr,
-					    kcmd->kbufs[i]->len);
+		dma_sync_sg_for_device(dev, kcmd->kbufs[i]->sgt->sgl,
+				       kcmd->kbufs[i]->sgt->orig_nents,
+				       DMA_BIDIRECTIONAL);
 	}
 
 	if (kcmd->state != KCMD_STATE_PPG_START)
@@ -861,6 +856,7 @@ void ipu_psys_handle_events(struct ipu_psys *psys)
 int ipu_psys_fh_init(struct ipu_psys_fh *fh)
 {
 	struct ipu_psys *psys = fh->psys;
+	struct device *dev = &psys->adev->auxdev.dev;
 	struct ipu_psys_buffer_set *kbuf_set, *kbuf_set_tmp;
 	struct ipu_psys_scheduler *sched = &fh->sched;
 	int i;
@@ -874,10 +870,10 @@ int ipu_psys_fh_init(struct ipu_psys_fh *fh)
 		kbuf_set = kzalloc(sizeof(*kbuf_set), GFP_KERNEL);
 		if (!kbuf_set)
 			goto out_free_buf_sets;
-		kbuf_set->kaddr = ipu6_dma_alloc(psys->adev,
-						 IPU_PSYS_BUF_SET_MAX_SIZE,
-						 &kbuf_set->dma_addr,
-						 GFP_KERNEL, 0);
+		kbuf_set->kaddr = dma_alloc_attrs(dev,
+						  IPU_PSYS_BUF_SET_MAX_SIZE,
+						  &kbuf_set->dma_addr,
+						  GFP_KERNEL, 0);
 		if (!kbuf_set->kaddr) {
 			kfree(kbuf_set);
 			goto out_free_buf_sets;
@@ -891,7 +887,7 @@ int ipu_psys_fh_init(struct ipu_psys_fh *fh)
 out_free_buf_sets:
 	list_for_each_entry_safe(kbuf_set, kbuf_set_tmp,
 				 &sched->buf_sets, list) {
-		ipu6_dma_free(psys->adev, kbuf_set->size, kbuf_set->kaddr,
+		dma_free_attrs(dev, kbuf_set->size, kbuf_set->kaddr,
 			      kbuf_set->dma_addr, 0);
 		list_del(&kbuf_set->list);
 		kfree(kbuf_set);
@@ -982,7 +978,7 @@ int ipu_psys_fh_deinit(struct ipu_psys_fh *fh)
 
 	mutex_lock(&sched->bs_mutex);
 	list_for_each_entry_safe(kbuf_set, kbuf_set0, &sched->buf_sets, list) {
-		ipu6_dma_free(psys->adev, kbuf_set->size, kbuf_set->kaddr,
+		dma_free_attrs(dev, kbuf_set->size, kbuf_set->kaddr,
 			      kbuf_set->dma_addr, 0);
 		list_del(&kbuf_set->list);
 		kfree(kbuf_set);
-- 
2.43.0

